[#]: subject: "Find bugs with the git bisect command"
[#]: via: "https://opensource.com/article/22/11/git-bisect"
[#]: author: "Dwayne McDaniel https://opensource.com/users/dwaynemcdaniel"
[#]: collector: "lkxed"
[#]: translator: "chai001125"
[#]: reviewer: " "
[#]: publisher: " "
[#]: url: " "

使用 git bisect 命令定位首次引入错误的提交
======

你是不是有过这样的经历：发现代码中有 <ruby>错误<rt> bug </rt></ruby>，但不知道这个错误是什么时候第一次引入的。这有可能是因为，某个人提交了一份有错误的代码，但没有在他的 Git <ruby>提交<rt> commit </rt></ruby> 消息中声明这个错误。这个错误可能已经存在了几周、几个月甚至几年，这意味着你需要搜索数百或数千个提交，才能找到问题何时出现的。而 `git bisect` 命令能够完美地解决这个问题！

`git bisect` 命令是一个强大的工具。你可以给 `git bisect` 命令一个范围，一端是一个已知的好状态，另一端是一个已知的坏状态。它会自动地确认当前范围的中点，在这个中点上进行测试，然后要求你告诉它那次提交是一个 <ruby>好提交<rt> good commit </rt></ruby> 还是一个 <ruby>坏提交<rt> bad commit </rt></ruby>，然后它会重复这一“二分查找”的过程，直到你找到首次引入错误的那一次提交。

![Image of Zeno's paradox of Achilles.][1]

这个“数学”工具是利用“二分查找”来找到错误之处的。`git bisect` 命令通过**查看中点**，然后由你来决定它是提交列表的新起点（即 bad commit ）还是新终点(即 good commit)，进而来缩小查找范围，如此在几次查找中你可以就能定位到有错误的提交。即使你有 10,000 个提交要检查，最多只需要 13 次查找，就能很快地定位到首次引入错误的提交。

- commit 1 bad <> commit 10,000 good => commit 5,000 is bad
- commit 5,000 bad <> commit 10,000 good => commit 7,500 is good
- commit 5,000 bad <> commit 7,500 good => commit 6,250 is good
- commit 5,000 bad <> commit 6,250 good => commit 5,625 is bad
- commit 5,625 bad <> commit 6,250 good => commit 5,938 is bad
- commit 5,938 bad <> commit 6,250 good => commit 6,094 is good
- commit 5,938 bad <> commit 6,094 good => commit 6,016 is bad
- commit 6,016 bad <> commit 6,094 good => commit 6,055 is good
- commit 6,016 bad <> commit 6,055 good => commit 6,036 is bad
- commit 6036 bad <> commit 6055 good => commit 6046 is bad
- commit 6,046 bad <> commit 6,055 good => commit 6,050 is bad
- commit 6,050 bad <> commit 6,055 good => commit 6,053 is good
- commit 6,053 bad <> commit 6,055 good => commit 6,054 is good

对于上面这个例子，我们能知道 10,000 个提交中的第一个错误提交是第 6053 次提交。对于 `git bisect` 命令，最多需要几分钟就能完成检索。但是如果要一个一个查找每个提交是否错误，我甚至无法想象需要多长时间。

### 使用 Git bisect 命令

`git bisect` 命令使用起来非常简单：

（LCTT 译注：使用 `git bisect start` 命令来进入 bisect 模式，并且该命令指定了一个检查范围。它会告诉我们一共有多少次提交，大概需要几步就可以定位到具体的提交。）

```
$ git bisect start
$ git bisect bad        # Git assumes you mean HEAD by default
$ git bisect good <ref> # specify a tag or commit ID for <ref>
```

Git 检查中间的提交，并等待你声明这次提交是一个好提交还是一个坏提交：

（LCTT 译注：如果某一提交是可以通过的，则使用 `git bisect good` 命令标记；同样地，如果某一提交不能通过，则使用 `git bisect bad` 命令标记。）

```
$ git bisect good
## or
$ git bisect bad
```

然后，`git bisect` 工具重复检查好提交和坏提交中间的那次提交，直到你告诉它：

```
$ git bisect reset
```

一些高级用户甚至可以自己编写脚本，来确定提交的好坏状态、并在找到特定提交时采取某一补救措施。你可能不会每天都使用 `git bisect` 命令，但当你需要它来定位首次引入错误的提交时，它会是一个很有用的救星。

--------------------------------------------------------------------------------

via: https://opensource.com/article/22/11/git-bisect

作者：[Dwayne McDaniel][a]
选题：[lkxed][b]
译者：[chai001125](https://github.com/chai001125)
校对：[校对者ID](https://github.com/校对者ID)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出

[a]: https://opensource.com/users/dwaynemcdaniel
[b]: https://github.com/lkxed
[1]: https://opensource.com/sites/default/files/2022-11/beyondgit.paradox.png
